Synchronized

三种使用方式：
1、修饰实例方法，作用于当前对象实例加锁，进入同步代码块前要获得当前对象实例的锁
2、修饰静态方法，作用于当前类对象加锁，进入同步代码块之前要获得当前类对象的锁
3、修饰代码块，制定加锁对象，对给定对象加锁，进入同步代码块之前要活的给定对象的锁
	synchronized(this)锁定当前实例对象
	synchronized(class)锁定当前类对象
	
synchronized关键字底层属于jvm层面
synchronized同步语句块实现使用：monitorenter开始/monitorexit结束
synchronized同步方法实现使用：ACC_SYNCHRONIZED标识

jdk1.6之前synchronized是重量级锁，效率低下。JDK1.6之后引入大量优化，如：自旋锁、锁消除、锁粗化、偏向锁、轻量锁等技术减小锁的开销

锁的四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态
状态之间不可降级

1、偏向锁
和引入轻量级锁目的很像，都是为了没有多线程竞争的前提下，减少传统的重量级锁对操作系统造成的消耗。
不同：轻量级锁在无竞争的情况下使用CAS代替使用互斥锁
      偏向锁在无竞争的情况下会把整个同步都消除掉
偏向锁：偏向第一个获取它的线程，如果接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要同步。
竞争激励的场合，偏向锁就失效，偏向锁失效后  ->  轻量级锁

2、轻量级锁
轻量级锁的加锁和解锁都用到了CAS操作
不是为了代替重量级锁，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁不需要申请互斥量。
轻量级锁提升程序同步性能：对于绝大部分锁，在整个竞争周期是不存在竞争的。
没有竞争，轻量级锁使用CAS操作避免了使用互斥操作的开销。
如果存在锁竞争，轻量级锁更慢（因为除了互斥量的开销外，还有额外的CAS操作）

3、自旋锁和自适应自旋
轻量级锁失败，避免线程真实的在操作系统层面挂起
为了让一个线程等待，只需让线程执行一个忙循环（自旋）
默认关闭，可通过--XX:+UseSpinning打开



Synchronized和ReenTrantLock

































